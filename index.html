<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Random Forest Trainer with Facade</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2rem;
            max-width: 1400px;
            background: #fafafa;
        }

        input,
        select,
        textarea,
        button {
            margin: 0.5rem 0;
        }

        button {
            padding: 8px 16px;
            cursor: pointer;
            background: #5a5a5a;
            color: white;
            border: none;
            border-radius: 0;
        }

        button:hover {
            background: #4a4a4a;
        }

        button:active {
            background: #3a3a3a;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .section {
            margin-bottom: 2rem;
            border-bottom: 1px solid #ccc;
            padding-bottom: 1rem;
            background: #fff;
            padding: 1rem;
            border-radius: 8px;
        }

        label {
            display: block;
            margin-top: 0.5rem;
        }

        .results {
            background-color: #f5f5f5;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
        }

        .metric {
            margin: 0.5rem 0;
            font-weight: bold;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        .facade-section {
            background-color: #e8f4f8;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .facade-controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.5rem;
        }

        .facade-output {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .inline-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .warning {
            color: #b36b00;
            background-color: #fff3cd;
            padding: 0.5rem;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .tree-viz {
            font-family: monospace;
            background-color: #f9f9f9;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: #4285f4;
            transition: width 0.3s;
        }
    </style>
</head>

<body>
    <h1>Random Forest Trainer with Facade</h1>

    <div class="section">
        <h2>Forest Configuration</h2>
        <div class="inline-controls">
            <label>Number of Trees: <input type="number" id="numTrees" value="10" min="1" max="100"></label>
            <label>Max Depth: <input type="number" id="maxDepth" value="5" min="1" max="20"></label>
            <label>Min Samples Leaf: <input type="number" id="minSamplesLeaf" value="1" min="1"></label>
            <label>Min Samples Split: <input type="number" id="minSamplesSplit" value="2" min="2"></label>
        </div>
        <div class="inline-controls">
            <label>Task Type:
                <select id="taskType">
                    <option value="classification" selected>Classification</option>
                    <option value="regression">Regression</option>
                </select>
            </label>
            <label>Criterion:
                <select id="criterion">
                    <option value="gini" selected>Gini</option>
                    <option value="entropy">Entropy</option>
                    <option value="mse">MSE</option>
                </select>
            </label>
            <label>Random Seed: <input type="number" id="randomSeed" value="42" min="0"></label>
        </div>
        <button onclick="createForest()">Create Forest</button>
        <span id="forestStatus" style="margin-left:1rem;"></span>
    </div>

    <div class="section">
        <h2>Generate Test Data</h2>
        <div class="inline-controls">
            <label>Samples per Class: <input type="number" id="samplesPerClass" value="100" min="10"></label>
            <label>Number of Features: <input type="number" id="numFeatures" value="4" min="2" max="20"></label>
            <label>Number of Classes: <input type="number" id="numClasses" value="3" min="2" max="5"></label>
        </div>
        <button onclick="generateData()">Generate Data</button>
        <span id="dataStatus"></span>
    </div>

    <div class="section">
        <h2>Train Forest</h2>
        <button onclick="trainForest()">Train Forest</button>
        <div id="trainStatus"></div>
        <div class="progress-bar" id="trainProgressBar" style="display:none;">
            <div class="progress-fill" id="trainProgressFill"></div>
        </div>
        <div id="trainResults" class="results" style="display:none;"></div>
    </div>

    <div class="section">
        <h2>Forest Architecture</h2>
        <div id="forestViz"></div>
    </div>

    <div class="section">
        <h2>Save/Load Forest</h2>
        <div class="inline-controls">
            <button onclick="saveForest()">Save Forest (.json)</button>
            <button onclick="loadForest()">Load Forest (.json)</button>
            <input type="file" id="modelFile" accept=".json" style="display:none;">
            <span id="loadStatus" style="margin-left:1rem;"></span>
        </div>
    </div>

    <div class="section">
        <h2>Predict</h2>
        <label>Input Features (comma separated):
            <input type="text" id="predictInput" value="0.2,0.4,0.6,0.8" style="width:400px;">
        </label>
        <button onclick="predict()">Predict</button>
        <div id="predictOutput"></div>
    </div>

    <div class="section facade-section">
        <h2>ðŸ”§ Facade API Explorer</h2>
        <p>Inspect and modify individual trees and their nodes:</p>

        <div class="facade-controls">
            <label>Tree Index: <input type="number" id="facadeTreeIdx" value="0" min="0"></label>
            <label>Node Index: <input type="number" id="facadeNodeIdx" value="0" min="0"></label>
            <label>Feature Index: <input type="number" id="facadeFeatureIdx" value="0" min="0"></label>
        </div>

        <h3>Tree Information</h3>
        <button onclick="facadeGetTreeInfo()">Get Tree Info</button>
        <button onclick="facadeGetTreeDepth()">Get Tree Depth</button>
        <button onclick="facadeGetTreeNumNodes()">Get Num Nodes</button>
        <button onclick="facadeGetTreeNumLeaves()">Get Num Leaves</button>
        <button onclick="facadeVisualizeTree()">Visualize Tree</button>

        <h3>Node Information</h3>
        <button onclick="facadeGetNodeDetails()">Get Node Details</button>
        <button onclick="facadeIsLeaf()">Is Leaf?</button>
        <button onclick="facadeGetFeatureIndex()">Get Feature Index</button>
        <button onclick="facadeGetThreshold()">Get Threshold</button>
        <button onclick="facadeGetPrediction()">Get Prediction</button>
        <button onclick="facadeGetImpurity()">Get Impurity</button>

        <h3>Tree Manipulation</h3>
        <label>New Threshold: <input type="number" id="newThreshold" value="0.5" step="0.01"></label>
        <button onclick="facadeModifySplit()">Modify Split</button>
        <label>New Leaf Value: <input type="number" id="newLeafValue" value="1" step="0.1"></label>
        <button onclick="facadeModifyLeaf()">Modify Leaf</button>
        <button onclick="facadePruneNode()">Prune Node</button>
        <button onclick="facadeConvertToLeaf()">Convert to Leaf</button>

        <h3>Forest Management</h3>
        <button onclick="facadeAddTree()">Add New Tree</button>
        <button onclick="facadeRemoveTree()">Remove Tree</button>
        <button onclick="facadeRetrainTree()">Retrain Tree</button>
        <button onclick="facadeGetNumTrees()">Get Num Trees</button>

        <h3>Feature Analysis</h3>
        <button onclick="facadeGetFeatureImportance()">Get Feature Importance</button>
        <button onclick="facadeGetFeatureUsage()">Get Feature Usage</button>
        <button onclick="facadeShowFeatureHeatmap()">Show Feature Heatmap</button>

        <h3>OOB & Diagnostics</h3>
        <button onclick="facadeGetOOBError()">Get OOB Error</button>
        <button onclick="facadeGetOOBSummary()">Get OOB Summary</button>
        <button onclick="facadeTrackSample()">Track Sample</button>
        <label>Sample Index: <input type="number" id="sampleIdx" value="0" min="0"></label>

        <h3>Output</h3>
        <div id="facadeOutput" class="facade-output">Facade output will appear here...</div>
    </div>

    <script>
        // ==================== Constants ====================
        const MAX_DEPTH = 50;
        const MIN_SAMPLES = 1;

        // ==================== Random Forest Classes ====================
        class TreeNode {
            constructor() {
                this.isLeaf = false;
                this.featureIndex = -1;
                this.threshold = 0;
                this.prediction = 0;
                this.classLabel = 0;
                this.impurity = 0;
                this.numSamples = 0;
                this.left = null;
                this.right = null;
            }
        }

        class DecisionTree {
            constructor(config) {
                this.root = null;
                this.maxDepth = config.maxDepth || 10;
                this.minSamplesLeaf = config.minSamplesLeaf || 1;
                this.minSamplesSplit = config.minSamplesSplit || 2;
                this.maxFeatures = config.maxFeatures || null;
                this.taskType = config.taskType || 'classification';
                this.criterion = config.criterion || 'gini';
                this.oobIndices = [];
            }

            calculateGini(targets, indices) {
                const counts = {};
                for (const idx of indices) {
                    const label = targets[idx];
                    counts[label] = (counts[label] || 0) + 1;
                }
                let gini = 1.0;
                const total = indices.length;
                for (const count of Object.values(counts)) {
                    const prob = count / total;
                    gini -= prob * prob;
                }
                return gini;
            }

            calculateEntropy(targets, indices) {
                const counts = {};
                for (const idx of indices) {
                    const label = targets[idx];
                    counts[label] = (counts[label] || 0) + 1;
                }
                let entropy = 0;
                const total = indices.length;
                for (const count of Object.values(counts)) {
                    if (count > 0) {
                        const prob = count / total;
                        entropy -= prob * Math.log2(prob);
                    }
                }
                return entropy;
            }

            calculateMSE(targets, indices) {
                const values = indices.map(i => targets[i]);
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
            }

            calculateImpurity(targets, indices) {
                if (this.criterion === 'gini') return this.calculateGini(targets, indices);
                if (this.criterion === 'entropy') return this.calculateEntropy(targets, indices);
                return this.calculateMSE(targets, indices);
            }

            findBestSplit(data, targets, indices, featureSubset) {
                let bestGain = 0;
                let bestFeature = -1;
                let bestThreshold = 0;
                const parentImpurity = this.calculateImpurity(targets, indices);

                for (const feat of featureSubset) {
                    const values = indices.map(i => data[i][feat]).sort((a, b) => a - b);
                    const uniqueVals = [...new Set(values)];

                    for (let i = 0; i < uniqueVals.length - 1; i++) {
                        const threshold = (uniqueVals[i] + uniqueVals[i + 1]) / 2;
                        const leftIndices = indices.filter(idx => data[idx][feat] <= threshold);
                        const rightIndices = indices.filter(idx => data[idx][feat] > threshold);

                        if (leftIndices.length < this.minSamplesLeaf || rightIndices.length < this.minSamplesLeaf) continue;

                        const leftImpurity = this.calculateImpurity(targets, leftIndices);
                        const rightImpurity = this.calculateImpurity(targets, rightIndices);
                        const gain = parentImpurity - (leftIndices.length / indices.length) * leftImpurity -
                            (rightIndices.length / indices.length) * rightImpurity;

                        if (gain > bestGain) {
                            bestGain = gain;
                            bestFeature = feat;
                            bestThreshold = threshold;
                        }
                    }
                }
                return { bestFeature, bestThreshold, bestGain };
            }

            getMajorityClass(targets, indices) {
                const counts = {};
                for (const idx of indices) {
                    const label = targets[idx];
                    counts[label] = (counts[label] || 0) + 1;
                }
                return parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));
            }

            getMean(targets, indices) {
                return indices.reduce((sum, idx) => sum + targets[idx], 0) / indices.length;
            }

            buildTree(data, targets, indices, depth, featureSubset) {
                const node = new TreeNode();
                node.numSamples = indices.length;
                node.impurity = this.calculateImpurity(targets, indices);

                if (depth >= this.maxDepth || indices.length < this.minSamplesSplit || node.impurity < 1e-10) {
                    node.isLeaf = true;
                    if (this.taskType === 'classification') {
                        node.classLabel = this.getMajorityClass(targets, indices);
                        node.prediction = node.classLabel;
                    } else {
                        node.prediction = this.getMean(targets, indices);
                    }
                    return node;
                }

                const { bestFeature, bestThreshold, bestGain } = this.findBestSplit(data, targets, indices, featureSubset);

                if (bestGain === 0) {
                    node.isLeaf = true;
                    if (this.taskType === 'classification') {
                        node.classLabel = this.getMajorityClass(targets, indices);
                        node.prediction = node.classLabel;
                    } else {
                        node.prediction = this.getMean(targets, indices);
                    }
                    return node;
                }

                node.featureIndex = bestFeature;
                node.threshold = bestThreshold;
                const leftIndices = indices.filter(idx => data[idx][bestFeature] <= bestThreshold);
                const rightIndices = indices.filter(idx => data[idx][bestFeature] > bestThreshold);

                node.left = this.buildTree(data, targets, leftIndices, depth + 1, featureSubset);
                node.right = this.buildTree(data, targets, rightIndices, depth + 1, featureSubset);
                return node;
            }

            predictSample(node, sample) {
                if (!node) return 0;
                if (node.isLeaf) return node.prediction;
                if (sample[node.featureIndex] <= node.threshold) {
                    return this.predictSample(node.left, sample);
                }
                return this.predictSample(node.right, sample);
            }

            predict(sample) {
                return this.predictSample(this.root, sample);
            }
        }

        class RandomForest {
            constructor(config) {
                this.numTrees = config.numTrees || 10;
                this.maxDepth = config.maxDepth || 10;
                this.minSamplesLeaf = config.minSamplesLeaf || 1;
                this.minSamplesSplit = config.minSamplesSplit || 2;
                this.maxFeatures = config.maxFeatures || null;
                this.taskType = config.taskType || 'classification';
                this.criterion = config.criterion || 'gini';
                this.randomSeed = config.randomSeed || 42;
                this.trees = [];
                this.featureImportances = [];
                this.data = [];
                this.targets = [];
                this.rng = this.seededRandom(this.randomSeed);
            }

            seededRandom(seed) {
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }

            bootstrap(n) {
                const indices = [];
                const oobMask = new Array(n).fill(true);
                for (let i = 0; i < n; i++) {
                    const idx = Math.floor(this.rng() * n);
                    indices.push(idx);
                    oobMask[idx] = false;
                }
                return { indices, oobMask };
            }

            selectFeatures(numFeatures) {
                const maxFeat = this.maxFeatures || Math.floor(Math.sqrt(numFeatures));
                const features = Array.from({ length: numFeatures }, (_, i) => i);
                for (let i = features.length - 1; i > 0; i--) {
                    const j = Math.floor(this.rng() * (i + 1));
                    [features[i], features[j]] = [features[j], features[i]];
                }
                return features.slice(0, maxFeat);
            }

            fit(data, targets) {
                this.data = data;
                this.targets = targets;
                this.trees = [];
                this.featureImportances = new Array(data[0].length).fill(0);

                for (let i = 0; i < this.numTrees; i++) {
                    const { indices, oobMask } = this.bootstrap(data.length);
                    const featureSubset = this.selectFeatures(data[0].length);
                    const tree = new DecisionTree({
                        maxDepth: this.maxDepth,
                        minSamplesLeaf: this.minSamplesLeaf,
                        minSamplesSplit: this.minSamplesSplit,
                        taskType: this.taskType,
                        criterion: this.criterion
                    });
                    tree.oobIndices = oobMask;
                    tree.root = tree.buildTree(data, targets, indices, 0, featureSubset);
                    this.trees.push(tree);
                }
            }

            predict(sample) {
                if (this.taskType === 'classification') {
                    const votes = {};
                    for (const tree of this.trees) {
                        const pred = Math.round(tree.predict(sample));
                        votes[pred] = (votes[pred] || 0) + 1;
                    }
                    return parseInt(Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b));
                } else {
                    const sum = this.trees.reduce((s, tree) => s + tree.predict(sample), 0);
                    return sum / this.trees.length;
                }
            }

            calculateOOBError() {
                const predictions = new Array(this.data.length).fill(0);
                const counts = new Array(this.data.length).fill(0);
                const votes = this.data.map(() => ({}));

                for (let t = 0; t < this.trees.length; t++) {
                    for (let i = 0; i < this.data.length; i++) {
                        if (this.trees[t].oobIndices[i]) {
                            const pred = this.trees[t].predict(this.data[i]);
                            if (this.taskType === 'classification') {
                                const label = Math.round(pred);
                                votes[i][label] = (votes[i][label] || 0) + 1;
                            } else {
                                predictions[i] += pred;
                            }
                            counts[i]++;
                        }
                    }
                }

                let error = 0;
                let total = 0;
                for (let i = 0; i < this.data.length; i++) {
                    if (counts[i] > 0) {
                        if (this.taskType === 'classification') {
                            const pred = parseInt(Object.keys(votes[i]).reduce((a, b) => votes[i][a] > votes[i][b] ? a : b));
                            if (pred !== this.targets[i]) error++;
                        } else {
                            const pred = predictions[i] / counts[i];
                            error += Math.pow(pred - this.targets[i], 2);
                        }
                        total++;
                    }
                }
                return total > 0 ? error / total : 0;
            }
            
            // Convert tree node to plain object for JSON serialization
            treeNodeToObject(node) {
                if (!node) return null;
                
                const obj = { isLeaf: node.isLeaf };
                
                if (node.isLeaf) {
                    obj.prediction = node.prediction;
                    obj.classLabel = node.classLabel;
                } else {
                    obj.featureIndex = node.featureIndex;
                    obj.threshold = node.threshold;
                    obj.impurity = node.impurity;
                    obj.numSamples = node.numSamples;
                    obj.left = this.treeNodeToObject(node.left);
                    obj.right = this.treeNodeToObject(node.right);
                }
                
                return obj;
            }
            
            toJSON() {
                // Export in Pascal-compatible format (snake_case)
                const payload = {
                    num_trees: this.numTrees,
                    max_depth: this.maxDepth,
                    min_samples_leaf: this.minSamplesLeaf,
                    min_samples_split: this.minSamplesSplit,
                    max_features: this.maxFeatures || 0,
                    num_features: this.data[0]?.length || 0,
                    num_samples: this.data.length,
                    task_type: this.taskType,
                    criterion: this.criterion,
                    random_seed: this.randomSeed,
                    trees: this.trees.map(tree => tree ? this.treeNodeToObject(tree.root) : null)
                };
                
                // Add feature importances if calculated
                if (this.featureImportances && this.featureImportances.length > 0) {
                    const hasImportances = this.featureImportances.some(x => x !== 0);
                    if (hasImportances) {
                        payload.feature_importances = this.featureImportances.slice();
                    }
                }
                
                return JSON.stringify(payload);
            }
            
            static fromJSON(json) {
                const obj = typeof json === "string" ? JSON.parse(json) : json;
                
                const config = {
                    numTrees: obj.num_trees || obj.numTrees || 10,
                    maxDepth: obj.max_depth || obj.maxDepth || 10,
                    minSamplesLeaf: obj.min_samples_leaf || obj.minSamplesLeaf || 1,
                    minSamplesSplit: obj.min_samples_split || obj.minSamplesSplit || 2,
                    maxFeatures: obj.max_features || obj.maxFeatures || null,
                    taskType: obj.task_type || obj.taskType || 'classification',
                    criterion: obj.criterion || 'gini',
                    randomSeed: obj.random_seed || obj.randomSeed || 42
                };
                
                const rf = new RandomForest(config);
                rf.numFeatures = obj.num_features || obj.numFeatures || 0;
                rf.numSamples = obj.num_samples || obj.numSamples || 0;
                
                // Load feature importances if present
                if (obj.feature_importances && Array.isArray(obj.feature_importances)) {
                    rf.featureImportances = obj.feature_importances.slice();
                }
                
                // Load trees - Pascal stores root nodes directly in the trees array
                if (obj.trees && Array.isArray(obj.trees)) {
                    rf.trees = [];
                    for (let i = 0; i < obj.trees.length; i++) {
                        const treeData = obj.trees[i];
                        if (treeData !== null) {
                            const tree = new DecisionTree(config);
                            // Pascal format: trees[i] is the root node directly
                            if (treeData.isLeaf !== undefined || treeData.featureIndex !== undefined) {
                                tree.root = treeData;
                            } else if (treeData.root !== undefined) {
                                tree.root = treeData.root;
                            }
                            tree.oobIndices = [];
                            rf.trees.push(tree);
                        } else {
                            const tree = new DecisionTree(config);
                            tree.root = null;
                            tree.oobIndices = [];
                            rf.trees.push(tree);
                        }
                    }
                }
                
                return rf;
            }
            
            getNumFeatures() {
                return this.data[0]?.length || this.numFeatures || 0;
            }
            
            getNumTrees() {
                return this.trees.filter(t => t && t.root).length;
            }
        }

        // ==================== Facade Class ====================
        class RandomForestFacade {
            constructor(forest) {
                this.forest = forest;
            }

            getTreeInfo(treeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return null;
                const tree = this.forest.trees[treeIdx];
                return {
                    treeId: treeIdx,
                    maxDepth: this.getTreeDepth(tree.root),
                    numNodes: this.countNodes(tree.root),
                    numLeaves: this.countLeaves(tree.root),
                    criterion: tree.criterion
                };
            }

            getTreeDepth(node) {
                if (!node) return 0;
                if (node.isLeaf) return 1;
                return 1 + Math.max(this.getTreeDepth(node.left), this.getTreeDepth(node.right));
            }

            countNodes(node) {
                if (!node) return 0;
                return 1 + this.countNodes(node.left) + this.countNodes(node.right);
            }

            countLeaves(node) {
                if (!node) return 0;
                if (node.isLeaf) return 1;
                return this.countLeaves(node.left) + this.countLeaves(node.right);
            }

            findNode(node, nodeIdx, currentIdx = { value: 0 }) {
                if (!node) return null;
                if (currentIdx.value === nodeIdx) return node;
                currentIdx.value++;
                const leftResult = this.findNode(node.left, nodeIdx, currentIdx);
                if (leftResult) return leftResult;
                return this.findNode(node.right, nodeIdx, currentIdx);
            }

            getNodeDetails(treeIdx, nodeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return null;
                const tree = this.forest.trees[treeIdx];
                const node = this.findNode(tree.root, nodeIdx);
                if (!node) return null;
                return {
                    isLeaf: node.isLeaf,
                    featureIndex: node.featureIndex,
                    threshold: node.threshold,
                    prediction: node.prediction,
                    classLabel: node.classLabel,
                    impurity: node.impurity,
                    numSamples: node.numSamples
                };
            }

            modifySplit(treeIdx, nodeIdx, newThreshold) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                const tree = this.forest.trees[treeIdx];
                const node = this.findNode(tree.root, nodeIdx);
                if (!node || node.isLeaf) return false;
                node.threshold = newThreshold;
                return true;
            }

            modifyLeafValue(treeIdx, nodeIdx, newValue) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                const tree = this.forest.trees[treeIdx];
                const node = this.findNode(tree.root, nodeIdx);
                if (!node || !node.isLeaf) return false;
                node.prediction = newValue;
                node.classLabel = Math.round(newValue);
                return true;
            }

            pruneNode(treeIdx, nodeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                const tree = this.forest.trees[treeIdx];
                const node = this.findNode(tree.root, nodeIdx);
                if (!node || node.isLeaf) return false;
                node.left = null;
                node.right = null;
                node.isLeaf = true;
                return true;
            }

            convertToLeaf(treeIdx, nodeIdx, leafValue) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                const tree = this.forest.trees[treeIdx];
                const node = this.findNode(tree.root, nodeIdx);
                if (!node) return false;
                node.left = null;
                node.right = null;
                node.isLeaf = true;
                node.prediction = leafValue;
                node.classLabel = Math.round(leafValue);
                node.featureIndex = -1;
                node.threshold = 0;
                return true;
            }

            visualizeTree(treeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return '';
                const tree = this.forest.trees[treeIdx];
                return this.visualizeNode(tree.root, 0);
            }

            visualizeNode(node, depth) {
                if (!node) return '';
                const indent = '  '.repeat(depth);
                if (node.isLeaf) {
                    return `${indent}[Leaf] -> ${node.prediction.toFixed(2)} (n=${node.numSamples})\n`;
                }
                let result = `${indent}[Split] Feature ${node.featureIndex} <= ${node.threshold.toFixed(4)} (n=${node.numSamples}, imp=${node.impurity.toFixed(4)})\n`;
                result += this.visualizeNode(node.left, depth + 1);
                result += this.visualizeNode(node.right, depth + 1);
                return result;
            }

            addTree() {
                if (!this.forest.data.length) return false;
                const { indices } = this.forest.bootstrap(this.forest.data.length);
                const featureSubset = this.forest.selectFeatures(this.forest.data[0].length);
                const tree = new DecisionTree({
                    maxDepth: this.forest.maxDepth,
                    minSamplesLeaf: this.forest.minSamplesLeaf,
                    minSamplesSplit: this.forest.minSamplesSplit,
                    taskType: this.forest.taskType,
                    criterion: this.forest.criterion
                });
                tree.root = tree.buildTree(this.forest.data, this.forest.targets, indices, 0, featureSubset);
                this.forest.trees.push(tree);
                return true;
            }

            removeTree(treeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                this.forest.trees.splice(treeIdx, 1);
                return true;
            }

            retrainTree(treeIdx) {
                if (treeIdx < 0 || treeIdx >= this.forest.trees.length) return false;
                if (!this.forest.data.length) return false;
                const { indices, oobMask } = this.forest.bootstrap(this.forest.data.length);
                const featureSubset = this.forest.selectFeatures(this.forest.data[0].length);
                const tree = this.forest.trees[treeIdx];
                tree.oobIndices = oobMask;
                tree.root = tree.buildTree(this.forest.data, this.forest.targets, indices, 0, featureSubset);
                return true;
            }

            getFeatureImportance() {
                // Simplified feature importance based on usage frequency
                const importance = new Array(this.forest.data[0]?.length || 0).fill(0);
                for (const tree of this.forest.trees) {
                    this.collectFeatureUsage(tree.root, importance);
                }
                const total = importance.reduce((a, b) => a + b, 0);
                return total > 0 ? importance.map(v => v / total) : importance;
            }

            collectFeatureUsage(node, importance) {
                if (!node || node.isLeaf) return;
                importance[node.featureIndex]++;
                this.collectFeatureUsage(node.left, importance);
                this.collectFeatureUsage(node.right, importance);
            }
        }

        // ==================== Global Variables ====================
        let forest = null;
        let facade = null;
        let trainData = [];
        let trainTargets = [];

        // ==================== Forest Visualization ====================
        function visualizeForest(forest, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const numTrees = forest.numTrees || 0;
            const numFeatures = forest.getNumFeatures() || 0;
            const trainedTrees = forest.getNumTrees() || 0;
            const taskType = forest.taskType || 'classification';
            
            const spacing = 60;
            const padding = 20;
            const legendSpace = 120;
            const treeDisplayCount = Math.min(numTrees, 15);
            const totalWidth = Math.max(500, legendSpace + padding * 2 + 120 + treeDisplayCount * spacing + 120);
            const totalHeight = 200;
            
            const svgContainer = document.createElement('div');
            svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('style', 'display: block;');
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <linearGradient id="inputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#4285f4;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#1967d2;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="treeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#34a853;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#188038;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="treeUntrainedGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#9e9e9e;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#616161;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="outputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
                </linearGradient>
            `;
            svg.appendChild(defs);
            
            const cy = totalHeight / 2;
            let xPos = padding + legendSpace;
            
            drawForestBox(svg, xPos, cy, 'Input', `${numFeatures} feat`, 'url(#inputGrad)', '#1967d2');
            xPos += 100;
            
            drawLine(svg, xPos - 40, cy, xPos + 10, cy - 30);
            drawLine(svg, xPos - 40, cy, xPos + 10, cy);
            drawLine(svg, xPos - 40, cy, xPos + 10, cy + 30);
            xPos += 20;
            
            for (let i = 0; i < treeDisplayCount; i++) {
                const isTrained = i < trainedTrees;
                const treeY = cy + (i % 3 - 1) * 35;
                drawTreeIcon(svg, xPos, treeY, i + 1, isTrained);
                xPos += spacing;
            }
            
            if (numTrees > treeDisplayCount) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', xPos - 30);
                text.setAttribute('y', cy + 5);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '14');
                text.setAttribute('fill', '#666');
                text.textContent = `+${numTrees - treeDisplayCount}`;
                svg.appendChild(text);
                xPos += 30;
            }
            
            drawLine(svg, xPos - 20, cy - 30, xPos + 30, cy);
            drawLine(svg, xPos - 20, cy, xPos + 30, cy);
            drawLine(svg, xPos - 20, cy + 30, xPos + 30, cy);
            xPos += 40;
            
            const outputLabel = taskType === 'classification' ? 'Vote' : 'Mean';
            drawForestBox(svg, xPos, cy, 'Output', outputLabel, 'url(#outputGrad)', '#f57d00');
            
            drawForestLegend(svg, padding + 5, cy - 50, trainedTrees, numTrees);
            
            svgContainer.appendChild(svg);
            container.innerHTML = '';
            container.appendChild(svgContainer);
        }

        function drawForestBox(svg, x, cy, label1, label2, fill, stroke) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x - 30);
            box.setAttribute('y', cy - 35);
            box.setAttribute('width', 60);
            box.setAttribute('height', 70);
            box.setAttribute('fill', fill);
            box.setAttribute('stroke', stroke);
            box.setAttribute('stroke-width', 1.5);
            box.setAttribute('rx', 3);
            g.appendChild(box);
            
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', x);
            text1.setAttribute('y', cy - 8);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('font-size', '10');
            text1.setAttribute('font-weight', 'bold');
            text1.setAttribute('fill', 'white');
            text1.textContent = label1;
            g.appendChild(text1);
            
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('x', x);
            text2.setAttribute('y', cy + 8);
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('font-size', '9');
            text2.setAttribute('fill', 'white');
            text2.textContent = label2;
            g.appendChild(text2);
            
            svg.appendChild(g);
        }

        function drawTreeIcon(svg, x, cy, treeNum, isTrained) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const fill = isTrained ? 'url(#treeGrad)' : 'url(#treeUntrainedGrad)';
            const stroke = isTrained ? '#188038' : '#616161';
            
            const trunk = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            trunk.setAttribute('x', x - 4);
            trunk.setAttribute('y', cy + 8);
            trunk.setAttribute('width', 8);
            trunk.setAttribute('height', 12);
            trunk.setAttribute('fill', '#8d6e63');
            trunk.setAttribute('rx', 1);
            g.appendChild(trunk);
            
            const crown = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            crown.setAttribute('points', `${x},${cy - 22} ${x - 18},${cy + 10} ${x + 18},${cy + 10}`);
            crown.setAttribute('fill', fill);
            crown.setAttribute('stroke', stroke);
            crown.setAttribute('stroke-width', 1);
            g.appendChild(crown);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', cy + 1);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '8');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', 'white');
            text.textContent = treeNum;
            g.appendChild(text);
            
            svg.appendChild(g);
        }

        function drawLine(svg, x1, y1, x2, y2) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#999');
            line.setAttribute('stroke-width', 1);
            svg.appendChild(line);
        }

        function drawForestLegend(svg, x, y, trainedTrees, totalTrees) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const box1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box1.setAttribute('x', x);
            box1.setAttribute('y', y);
            box1.setAttribute('width', 12);
            box1.setAttribute('height', 12);
            box1.setAttribute('fill', 'url(#treeGrad)');
            box1.setAttribute('stroke', '#188038');
            box1.setAttribute('rx', 2);
            g.appendChild(box1);
            
            const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label1.setAttribute('x', x + 16);
            label1.setAttribute('y', y + 10);
            label1.setAttribute('font-size', '9');
            label1.setAttribute('fill', '#333');
            label1.textContent = `Trained (${trainedTrees})`;
            g.appendChild(label1);
            
            const box2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box2.setAttribute('x', x);
            box2.setAttribute('y', y + 18);
            box2.setAttribute('width', 12);
            box2.setAttribute('height', 12);
            box2.setAttribute('fill', 'url(#treeUntrainedGrad)');
            box2.setAttribute('stroke', '#616161');
            box2.setAttribute('rx', 2);
            g.appendChild(box2);
            
            const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label2.setAttribute('x', x + 16);
            label2.setAttribute('y', y + 28);
            label2.setAttribute('font-size', '9');
            label2.setAttribute('fill', '#333');
            label2.textContent = `Untrained`;
            g.appendChild(label2);
            
            const label3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label3.setAttribute('x', x);
            label3.setAttribute('y', y + 50);
            label3.setAttribute('font-size', '9');
            label3.setAttribute('fill', '#666');
            label3.textContent = `Total: ${totalTrees}`;
            g.appendChild(label3);
            
            svg.appendChild(g);
        }

        // ==================== UI Functions ====================
        function createForest() {
            const config = {
                numTrees: parseInt(document.getElementById('numTrees').value),
                maxDepth: parseInt(document.getElementById('maxDepth').value),
                minSamplesLeaf: parseInt(document.getElementById('minSamplesLeaf').value),
                minSamplesSplit: parseInt(document.getElementById('minSamplesSplit').value),
                taskType: document.getElementById('taskType').value,
                criterion: document.getElementById('criterion').value,
                randomSeed: parseInt(document.getElementById('randomSeed').value)
                };
            forest = new RandomForest(config);
            facade = new RandomForestFacade(forest);
            document.getElementById('forestStatus').textContent = 'âœ“ Forest created';
            document.getElementById('forestStatus').style.color = 'green';
            visualizeForest(forest, 'forestViz');
        }

        function generateData() {
            const samplesPerClass = parseInt(document.getElementById('samplesPerClass').value);
            const numFeatures = parseInt(document.getElementById('numFeatures').value);
            const numClasses = parseInt(document.getElementById('numClasses').value);

            trainData = [];
            trainTargets = [];

            for (let cls = 0; cls < numClasses; cls++) {
                const centerOffset = cls * 2;
                for (let i = 0; i < samplesPerClass; i++) {
                    const sample = [];
                    for (let f = 0; f < numFeatures; f++) {
                        sample.push(centerOffset + (Math.random() - 0.5) * 2);
                    }
                    trainData.push(sample);
                    trainTargets.push(cls);
                }
            }

            document.getElementById('dataStatus').textContent =
                `âœ“ Generated ${trainData.length} samples with ${numFeatures} features`;
            document.getElementById('dataStatus').style.color = 'green';
        }

        function trainForest() {
            if (!forest) {
                alert('Please create forest first');
                return;
            }
            if (!trainData.length) {
                alert('Please generate data first');
                return;
            }

            const progressBar = document.getElementById('trainProgressBar');
            const progressFill = document.getElementById('trainProgressFill');
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';

            document.getElementById('trainStatus').textContent = 'Training...';

            setTimeout(() => {
                const startTime = Date.now();
                forest.fit(trainData, trainTargets);
                const endTime = Date.now();

                progressFill.style.width = '100%';

                const predictions = trainData.map(s => forest.predict(s));
                const correct = predictions.filter((p, i) => p === trainTargets[i]).length;
                const accuracy = correct / trainData.length;
                const oobError = forest.calculateOOBError();

                document.getElementById('trainStatus').textContent = 'âœ“ Training complete';
                document.getElementById('trainStatus').style.color = 'green';

                const results = document.getElementById('trainResults');
                results.style.display = 'block';
                results.innerHTML = `
                    <div class="metric">Training Accuracy: ${(accuracy * 100).toFixed(2)}%</div>
                    <div class="metric">OOB Error: ${oobError.toFixed(4)}</div>
                    <div class="metric">Training Time: ${endTime - startTime}ms</div>
                    <div class="metric">Number of Trees: ${forest.trees.length}</div>
                    <div class="metric">Samples: ${trainData.length}</div>
                `;

                visualizeForest(forest, 'forestViz');

                setTimeout(() => {
                    progressBar.style.display = 'none';
                }, 1000);
            }, 100);
        }

        function predict() {
            if (!forest || !forest.trees.length) {
                alert('Please train forest first');
                return;
            }

            const inputStr = document.getElementById('predictInput').value;
            const sample = inputStr.split(',').map(v => parseFloat(v.trim()));

            if (sample.some(isNaN)) {
                alert('Invalid input format');
                return;
            }

            const prediction = forest.predict(sample);
            const output = document.getElementById('predictOutput');
            output.innerHTML = `<div class="metric">Prediction: ${prediction.toFixed(4)}</div>`;
        }

        // ==================== Save/Load Functions ====================
        function saveForest() {
            if (!forest) {
                alert('Please create a forest first.');
                return;
            }
            
            const jsonStr = forest.toJSON();
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'forest-model.json';
            a.click();
            
            document.getElementById('loadStatus').textContent = 'âœ“ Forest saved.';
            document.getElementById('loadStatus').style.color = 'green';
        }
        
        function loadForest() {
            const fileInput = document.getElementById('modelFile');
            
            fileInput.onchange = function(evt) {
                const file = evt.target.files[0];
                if (!file) {
                    document.getElementById('loadStatus').textContent = 'No file selected';
                    return;
                }
                
                document.getElementById('loadStatus').textContent = 'Loading...';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        forest = RandomForest.fromJSON(e.target.result);
                        facade = new RandomForestFacade(forest);
                        
                        const trainedTrees = forest.getNumTrees();
                        const numFeatures = forest.getNumFeatures();
                        
                        // Update UI with loaded model config
                        document.getElementById('numTrees').value = forest.numTrees;
                        document.getElementById('maxDepth').value = forest.maxDepth;
                        document.getElementById('minSamplesLeaf').value = forest.minSamplesLeaf;
                        document.getElementById('minSamplesSplit').value = forest.minSamplesSplit;
                        document.getElementById('taskType').value = forest.taskType;
                        document.getElementById('criterion').value = forest.criterion;
                        document.getElementById('randomSeed').value = forest.randomSeed;
                        
                        // Update predict input placeholder
                        if (numFeatures > 0) {
                            const placeholderValues = Array(numFeatures).fill(0).map((_, i) => (i * 0.1).toFixed(1));
                            document.getElementById('predictInput').value = placeholderValues.join(',');
                        }
                        
                        document.getElementById('loadStatus').textContent = 
                            `âœ“ Loaded! Trees: ${forest.numTrees} (${trainedTrees} trained), ` +
                            `Features: ${numFeatures}, Samples: ${forest.numSamples}, ` +
                            `Task: ${forest.taskType}, Criterion: ${forest.criterion}`;
                        document.getElementById('loadStatus').style.color = 'green';
                        
                        document.getElementById('forestStatus').textContent = 'âœ“ Forest loaded from file';
                        document.getElementById('forestStatus').style.color = 'green';
                        
                        visualizeForest(forest, 'forestViz');
                        
                    } catch (err) {
                        document.getElementById('loadStatus').textContent = 'Error: ' + err.message;
                        document.getElementById('loadStatus').style.color = 'red';
                        console.error('Load error:', err);
                    }
                };
                
                reader.onerror = function(err) {
                    document.getElementById('loadStatus').textContent = 'Error reading file';
                    document.getElementById('loadStatus').style.color = 'red';
                };
                
                reader.readAsText(file);
            };
            
            fileInput.click();
        }

        // ==================== Facade Functions ====================
        function facadeOutput(text) {
            document.getElementById('facadeOutput').textContent = text;
        }

        function facadeGetTreeInfo() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const info = facade.getTreeInfo(idx);
            if (!info) {
                facadeOutput(`Error: Invalid tree index ${idx}`);
                return;
            }
            facadeOutput(
                `Tree ${info.treeId} Info:\n` +
                `Max Depth: ${info.maxDepth}\n` +
                `Num Nodes: ${info.numNodes}\n` +
                `Num Leaves: ${info.numLeaves}\n` +
                `Criterion: ${info.criterion}`
            );
        }

        function facadeGetTreeDepth() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const info = facade.getTreeInfo(idx);
            if (!info) {
                facadeOutput(`Error: Invalid tree index ${idx}`);
                return;
            }
            facadeOutput(`Tree ${idx} Depth: ${info.maxDepth}`);
        }

        function facadeGetTreeNumNodes() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const info = facade.getTreeInfo(idx);
            if (!info) {
                facadeOutput(`Error: Invalid tree index ${idx}`);
                return;
            }
            facadeOutput(`Tree ${idx} Num Nodes: ${info.numNodes}`);
        }

        function facadeGetTreeNumLeaves() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const info = facade.getTreeInfo(idx);
            if (!info) {
                facadeOutput(`Error: Invalid tree index ${idx}`);
                return;
            }
            facadeOutput(`Tree ${idx} Num Leaves: ${info.numLeaves}`);
        }

        function facadeVisualizeTree() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const viz = facade.visualizeTree(idx);
            if (!viz) {
                facadeOutput(`Error: Invalid tree index ${idx}`);
                return;
            }
            facadeOutput(viz);
        }

        function facadeGetNodeDetails() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(
                `Node ${nodeIdx} Details:\n` +
                `Is Leaf: ${details.isLeaf}\n` +
                `Feature Index: ${details.featureIndex}\n` +
                `Threshold: ${details.threshold.toFixed(4)}\n` +
                `Prediction: ${details.prediction.toFixed(4)}\n` +
                `Class Label: ${details.classLabel}\n` +
                `Impurity: ${details.impurity.toFixed(4)}\n` +
                `Num Samples: ${details.numSamples}`
            );
        }

        function facadeIsLeaf() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(`Node ${nodeIdx} is leaf: ${details.isLeaf}`);
        }

        function facadeGetFeatureIndex() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(`Node ${nodeIdx} feature index: ${details.featureIndex}`);
        }

        function facadeGetThreshold() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(`Node ${nodeIdx} threshold: ${details.threshold.toFixed(4)}`);
        }

        function facadeGetPrediction() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(`Node ${nodeIdx} prediction: ${details.prediction.toFixed(4)}`);
        }

        function facadeGetImpurity() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const details = facade.getNodeDetails(treeIdx, nodeIdx);
            if (!details) {
                facadeOutput(`Error: Invalid tree/node index`);
                return;
            }
            facadeOutput(`Node ${nodeIdx} impurity: ${details.impurity.toFixed(4)}`);
        }

        function facadeModifySplit() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const newThreshold = parseFloat(document.getElementById('newThreshold').value);
            const success = facade.modifySplit(treeIdx, nodeIdx, newThreshold);
            facadeOutput(success ?
                `âœ“ Modified split at tree ${treeIdx}, node ${nodeIdx} to threshold ${newThreshold.toFixed(4)}` :
                `Error: Could not modify split`);
        }

        function facadeModifyLeaf() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const newValue = parseFloat(document.getElementById('newLeafValue').value);
            const success = facade.modifyLeafValue(treeIdx, nodeIdx, newValue);
            facadeOutput(success ?
                `âœ“ Modified leaf value at tree ${treeIdx}, node ${nodeIdx} to ${newValue.toFixed(4)}` :
                `Error: Could not modify leaf (is it a leaf node?)`);
        }

        function facadePruneNode() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const success = facade.pruneNode(treeIdx, nodeIdx);
            facadeOutput(success ?
                `âœ“ Pruned node ${nodeIdx} in tree ${treeIdx}` :
                `Error: Could not prune node`);
        }

        function facadeConvertToLeaf() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const treeIdx = parseInt(document.getElementById('facadeTreeIdx').value);
            const nodeIdx = parseInt(document.getElementById('facadeNodeIdx').value);
            const newValue = parseFloat(document.getElementById('newLeafValue').value);
            const success = facade.convertToLeaf(treeIdx, nodeIdx, newValue);
            facadeOutput(success ?
                `âœ“ Converted node ${nodeIdx} in tree ${treeIdx} to leaf with value ${newValue.toFixed(4)}` :
                `Error: Could not convert to leaf`);
        }

        function facadeAddTree() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const success = facade.addTree();
            facadeOutput(success ?
                `âœ“ Added new tree. Total trees: ${forest.trees.length}` :
                `Error: Could not add tree (no training data?)`);
        }

        function facadeRemoveTree() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const success = facade.removeTree(idx);
            facadeOutput(success ?
                `âœ“ Removed tree ${idx}. Total trees: ${forest.trees.length}` :
                `Error: Could not remove tree`);
        }

        function facadeRetrainTree() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const idx = parseInt(document.getElementById('facadeTreeIdx').value);
            const success = facade.retrainTree(idx);
            facadeOutput(success ?
                `âœ“ Retrained tree ${idx}` :
                `Error: Could not retrain tree`);
        }

        function facadeGetNumTrees() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            facadeOutput(`Number of trees: ${forest.trees.length}`);
        }

        function facadeGetFeatureImportance() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const featureIdx = parseInt(document.getElementById('facadeFeatureIdx').value);
            const importance = facade.getFeatureImportance();
            if (featureIdx >= 0 && featureIdx < importance.length) {
                facadeOutput(`Feature ${featureIdx} importance: ${importance[featureIdx].toFixed(4)}`);
            } else {
                let output = 'Feature Importances:\n';
                importance.forEach((imp, i) => {
                    output += `Feature ${i}: ${imp.toFixed(4)}\n`;
                });
                facadeOutput(output);
            }
        }

        function facadeGetFeatureUsage() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const importance = facade.getFeatureImportance();
            let output = 'Feature Usage Summary:\n';
            importance.forEach((imp, i) => {
                const usageCount = Math.round(imp * forest.trees.length * 10);
                output += `Feature ${i}: ${usageCount} occurrences (importance: ${imp.toFixed(4)})\n`;
            });
            facadeOutput(output);
        }

        function facadeShowFeatureHeatmap() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const numFeatures = trainData[0]?.length || 0;
            const usage = Array(numFeatures).fill(0).map(() => Array(forest.trees.length).fill(false));

            forest.trees.forEach((tree, treeIdx) => {
                const collectUsage = (node) => {
                    if (!node || node.isLeaf) return;
                    usage[node.featureIndex][treeIdx] = true;
                    collectUsage(node.left);
                    collectUsage(node.right);
                };
                collectUsage(tree.root);
            });

            let output = 'Feature Usage Heatmap:\nFeat  ';
            for (let t = 0; t < Math.min(forest.trees.length, 20); t++) {
                output += t < 10 ? t + ' ' : (t % 10) + ' ';
            }
            output += '\n' + '-'.repeat(8 + Math.min(forest.trees.length, 20) * 2) + '\n';

            for (let f = 0; f < numFeatures; f++) {
                output += f.toString().padStart(4) + '  ';
                for (let t = 0; t < Math.min(forest.trees.length, 20); t++) {
                    output += usage[f][t] ? 'X ' : '. ';
                }
                const total = usage[f].filter(Boolean).length;
                output += ` ${total}\n`;
            }
            facadeOutput(output);
        }

        function facadeGetOOBError() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const oobError = forest.calculateOOBError();
            facadeOutput(`Global OOB Error: ${oobError.toFixed(4)}`);
        }

        function facadeGetOOBSummary() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            let output = 'OOB Summary:\n';
            output += 'Tree  OOB Samples  OOB Error\n';
            output += '-'.repeat(35) + '\n';

            forest.trees.forEach((tree, idx) => {
                const oobCount = tree.oobIndices.filter(Boolean).length;
                let errors = 0;
                let total = 0;

                trainData.forEach((sample, i) => {
                    if (tree.oobIndices[i]) {
                        const pred = tree.predict(sample);
                        if (forest.taskType === 'classification') {
                            if (Math.round(pred) !== trainTargets[i]) errors++;
                        } else {
                            errors += Math.pow(pred - trainTargets[i], 2);
                        }
                        total++;
                    }
                });

                const oobError = total > 0 ? errors / total : 0;
                output += `${idx.toString().padStart(4)}  ${oobCount.toString().padStart(10)}  ${oobError.toFixed(4)}\n`;
            });

            facadeOutput(output);
        }

        function facadeTrackSample() {
            if (!facade) {
                facadeOutput('Error: Forest not created');
                return;
            }
            const sampleIdx = parseInt(document.getElementById('sampleIdx').value);
            if (sampleIdx < 0 || sampleIdx >= trainData.length) {
                facadeOutput(`Error: Invalid sample index ${sampleIdx}`);
                return;
            }

            const sample = trainData[sampleIdx];
            let output = `Sample ${sampleIdx} Tracking:\n`;
            output += `Actual Target: ${trainTargets[sampleIdx]}\n\n`;
            output += 'Tree  In Bootstrap  OOB  Prediction\n';
            output += '-'.repeat(40) + '\n';

            forest.trees.forEach((tree, idx) => {
                const isOOB = tree.oobIndices[sampleIdx];
                const pred = tree.predict(sample);
                output += `${idx.toString().padStart(4)}  `;
                output += isOOB ? 'No         ' : 'Yes        ';
                output += isOOB ? 'Yes  ' : 'No   ';
                output += `${pred.toFixed(4)}\n`;
            });

            facadeOutput(output);
        }
    </script>
</body>

</html>
