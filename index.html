<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Facaded Random Forest (JS, Pascal Port)</title>
  <style>
    body { font-family: Arial, sans-serif; margin:2rem;}
    label, input, select, button, textarea { margin: 0.3rem 0; }
    .section { margin-bottom:2rem; }
    .results { background:#f5f5f5; padding:1rem; border-radius:5px; }
    .facade-output { font-family: monospace; background:#fff; border:1px solid #ccc; padding:0.5rem; white-space:pre-wrap; margin-top:5px;}
    .inline { display:inline-block; margin-right:1rem;}
  </style>
</head>
<body>
  <h1>Facaded Random Forest (JS, Pascal Port)</h1>

  <div class="section">
    <h2>Hyperparameters</h2>
    <label>Num Trees: <input type="number" id="numTrees" value="10" min="1" max="100"></label>
    <label>Max Depth: <input type="number" id="maxDepth" value="5" min="1" max="30"></label>
    <label>Min Samples Leaf: <input type="number" id="minSamplesLeaf" value="1" min="1" max="100"></label>
    <label>Min Samples Split: <input type="number" id="minSamplesSplit" value="2" min="2" max="100"></label>
    <label>Max Features: <input type="number" id="maxFeatures" value="0" min="0" max="15"></label>
    <label>Task Type:
      <select id="taskType"><option value="classification">Classification</option><option value="regression">Regression</option></select>
    </label>
    <label>Criterion:
      <select id="criterion">
        <option value="gini">Gini</option>
        <option value="entropy">Entropy</option>
        <option value="mse">MSE</option>
        <option value="variance">VarianceReduction</option>
      </select>
    </label>
    <button onclick="facade.setHyperparameters()">Set Hyperparameters</button>
  </div>

  <div class="section">
    <h2>Load Data</h2>
    <textarea id="csvInput" rows="6" cols="60">1,2,3,0
2,1,3,0
8,9,7,1
7,8,9,1
</textarea><br>
    <label>Features: <input type="number" id="numFeatures" value="3" min="1" max="15"></label>
    <label>Samples: <input type="number" id="numSamples" value="4" min="1" max="10000"></label>
    <button onclick="facade.loadCSV()">Load Data</button>
  </div>

  <div class="section">
    <h2>Train Forest</h2>
    <button onclick="facade.trainForest()">Train</button>
    <span id="trainStatus"></span>
  </div>

  <div class="section">
    <h2>Predict</h2>
    <label>Sample (comma separated): <input type="text" id="sampleInput" value="1,2,3"></label>
    <button onclick="facade.predictSample()">Predict</button>
    <div class="results" id="predictResult"></div>
  </div>

  <div class="section">
    <h2>Feature Importances</h2>
    <button onclick="facade.showFeatureImportances()">Show Importances</button>
    <div class="results" id="featureImportances"></div>
  </div>

  <div class="section">
    <h2>Forest Info</h2>
    <button onclick="facade.showForestInfo()">Show Info</button>
    <div class="results" id="forestInfo"></div>
  </div>

  <div class="section">
    <h2>Facade Output & API</h2>
    <button onclick="facade.inspectTree(0)">Inspect Tree 0</button>
    <div class="facade-output" id="facadeOutput"></div>
  </div>

  <script>
  "use strict";

  // --- Utility ---
  function zeros(n) { return Array(n).fill(0); }
  function range(n) { return Array.from({length:n}, (_,i)=>i); }
  function shuffle(array) {
    for (let i = array.length-1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [array[i],array[j]] = [array[j],array[i]];
    }
  }
  function parseCSV(txt, nFeatures) {
    const rows = [];
    txt.trim().split(/\n/).forEach(line => {
      const vals = line.split(',').map(Number);
      if (vals.length>=nFeatures+1) rows.push({features:vals.slice(0,nFeatures), target:vals[nFeatures]});
    });
    return rows;
  }

  // --- Decision Tree ---
  class TreeNode {
    constructor() {
      this.isLeaf = false;
      this.featureIndex = -1;
      this.threshold = 0;
      this.prediction = 0;
      this.classLabel = -1;
      this.impurity = 0;
      this.numSamples = 0;
      this.left = null;
      this.right = null;
    }
  }

  class DecisionTree {
    constructor(params, features, targets) {
      this.maxDepth = params.maxDepth;
      this.minSamplesLeaf = params.minSamplesLeaf;
      this.minSamplesSplit = params.minSamplesSplit;
      this.maxFeatures = params.maxFeatures;
      this.criterion = params.criterion;
      this.taskType = params.taskType;
      this.numFeatures = params.numFeatures;
      this.numSamples = params.numSamples;
      this.features = features;
      this.targets = targets;
      this.root = null;
    }
    fit(indices, depth=0) {
      const node = new TreeNode();
      node.numSamples = indices.length;
      node.impurity = this.calculateImpurity(indices);
      if (this.shouldStop(depth, indices.length, node.impurity)) {
        node.isLeaf = true;
        if (this.taskType==='classification')
          node.classLabel = this.getMajorityClass(indices),
          node.prediction = node.classLabel;
        else
          node.prediction = this.getMeanTarget(indices),
          node.classLabel = Math.round(node.prediction);
        return node;
      }
      // select feature subset
      const featureSet = range(this.numFeatures);
      shuffle(featureSet);
      const chosenFeatures = featureSet.slice(0, this.maxFeatures||this.numFeatures);
      // find best split
      const split = this.findBestSplit(indices, chosenFeatures);
      if (!split) {
        // create leaf
        node.isLeaf = true;
        if (this.taskType==='classification')
          node.classLabel = this.getMajorityClass(indices),
          node.prediction = node.classLabel;
        else
          node.prediction = this.getMeanTarget(indices),
          node.classLabel = Math.round(node.prediction);
        return node;
      }
      node.featureIndex = split.bestFeature;
      node.threshold = split.bestThreshold;
      node.left = this.fit(split.leftIndices, depth+1);
      node.right = this.fit(split.rightIndices, depth+1);
      return node;
    }
    shouldStop(depth, nIdx, impurity) {
      return depth>=this.maxDepth || nIdx<this.minSamplesSplit || nIdx<=this.minSamplesLeaf || impurity<1e-10;
    }
    getMajorityClass(indices) {
      const counts = {};
      for (const idx of indices) {
        const label = Math.round(this.targets[idx]);
        counts[label] = (counts[label]||0)+1;
      }
      return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
    }
    getMeanTarget(indices) {
      let sum=0; for (const idx of indices) sum += this.targets[idx];
      return sum/indices.length;
    }
    calculateImpurity(indices) {
      if (this.criterion==='gini') return this.calculateGini(indices);
      if (this.criterion==='entropy') return this.calculateEntropy(indices);
      if (this.criterion==='mse') return this.calculateMSE(indices);
      return this.calculateGini(indices);
    }
    calculateGini(indices) {
      const counts = {};
      for (const idx of indices) {
        const label = Math.round(this.targets[idx]);
        counts[label] = (counts[label]||0)+1;
      }
      const n = indices.length;
      let gini=1;
      Object.values(counts).forEach(cnt=>{
        const p=cnt/n;
        gini-=p*p;
      });
      return gini;
    }
    calculateEntropy(indices) {
      const counts = {};
      for (const idx of indices) {
        const label = Math.round(this.targets[idx]);
        counts[label] = (counts[label]||0)+1;
      }
      const n = indices.length;
      let entropy=0;
      Object.values(counts).forEach(cnt=>{
        const p=cnt/n;
        entropy-=p>0?p*Math.log2(p):0;
      });
      return entropy;
    }
    calculateMSE(indices) {
      const n = indices.length, mean = this.getMeanTarget(indices);
      let mse=0; for (const idx of indices) mse += (this.targets[idx]-mean)**2;
      return mse/n;
    }
    findBestSplit(indices, features) {
      let bestGain = -Infinity, bestFeature=-1, bestThreshold=0, bestLeft=[], bestRight=[];
      const parentImpurity = this.calculateImpurity(indices);
      for (const feat of features) {
        const values = indices.map(idx=>this.features[idx][feat]);
        const sorted = [...values].sort((a,b)=>a-b);
        for (let i=0; i<sorted.length-1; i++) {
          if (sorted[i]===sorted[i+1]) continue;
          const threshold = (sorted[i]+sorted[i+1])/2;
          const left=[], right=[];
          for (const idx of indices) {
            if (this.features[idx][feat]<=threshold) left.push(idx); else right.push(idx);
          }
          if (left.length<this.minSamplesLeaf||right.length<this.minSamplesLeaf) continue;
          const leftImp = this.calculateImpurity(left), rightImp = this.calculateImpurity(right);
          const gain = parentImpurity - (left.length/indices.length)*leftImp - (right.length/indices.length)*rightImp;
          if (gain>bestGain) {
            bestGain = gain; bestFeature=feat; bestThreshold=threshold; bestLeft=left; bestRight=right;
          }
        }
      }
      if (bestGain===-Infinity) return null;
      return {bestFeature, bestThreshold, bestGain, leftIndices:bestLeft, rightIndices:bestRight};
    }
    predict(sample) {
      let node=this.root;
      while(node && !node.isLeaf) {
        if (sample[node.featureIndex]<=node.threshold) node=node.left; else node=node.right;
      }
      return node?node.prediction:0;
    }
  }

  // --- Random Forest ---
  class RandomForest {
    constructor(params) {
      this.numTrees=params.numTrees||10;
      this.maxDepth=params.maxDepth||5;
      this.minSamplesLeaf=params.minSamplesLeaf||1;
      this.minSamplesSplit=params.minSamplesSplit||2;
      this.maxFeatures=params.maxFeatures||0;
      this.criterion=params.criterion||'gini';
      this.taskType=params.taskType||'classification';
      this.trees=[];
      this.numFeatures=params.numFeatures||0;
      this.numSamples=params.numSamples||0;
      this.features=[];
      this.targets=[];
      this.featureImportances=[];
    }
    loadData(features, targets, numFeatures, numSamples) {
      this.features=features;
      this.targets=targets;
      this.numFeatures=numFeatures;
      this.numSamples=numSamples;
      if (!this.maxFeatures || this.maxFeatures>numFeatures)
        this.maxFeatures=Math.max(1, this.taskType==='classification'?Math.round(Math.sqrt(numFeatures)):Math.round(numFeatures/3));
    }
    fit() {
      this.trees=[];
      for (let t=0; t<this.numTrees; t++) {
        // bootstrap indices
        const indices=range(this.numSamples).map(()=>Math.floor(Math.random()*this.numSamples));
        const tree = new DecisionTree(this, this.features, this.targets);
        tree.root = tree.fit(indices,0);
        this.trees.push(tree);
      }
      // feature importances after training
      this.featureImportances = this.getFeatureImportances();
    }
    predict(sample) {
      const votes = this.trees.map(tree=>tree.predict(sample));
      if (this.taskType==='classification') {
        const counts = {};
        for (const v of votes) counts[Math.round(v)] = (counts[Math.round(v)]||0)+1;
        return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      } else {
        return votes.reduce((a,b)=>a+b,0)/votes.length;
      }
    }
    predictBatch(samples) {
      return samples.map(s=>this.predict(s));
    }
    getFeatureImportances() {
      // Simple count of splits per feature (can be extended to actual gain)
      const importances = zeros(this.numFeatures);
      for (const tree of this.trees) {
        this._recurseFeatureCount(tree.root,importances);
      }
      const sum = importances.reduce((a,b)=>a+b,0);
      return importances.map(v=>sum>0?v/sum:0);
    }
    _recurseFeatureCount(node,arr) {
      if (!node||node.isLeaf) return;
      arr[node.featureIndex]++;
      this._recurseFeatureCount(node.left,arr);
      this._recurseFeatureCount(node.right,arr);
    }
    accuracy(predictions, actual) {
      let correct=0;
      for (let i=0; i<predictions.length; i++)
        if (Math.round(predictions[i])===Math.round(actual[i])) correct++;
      return correct/predictions.length;
    }
    mse(predictions, actual) {
      let sum=0;
      for (let i=0; i<predictions.length; i++)
        sum += (predictions[i]-actual[i])**2;
      return sum/predictions.length;
    }
  }

  // --- Facade ---
  class RandomForestFacade {
    constructor() {
      this.rf = new RandomForest({});
    }
    setHyperparameters() {
      const hp = {
        numTrees:parseInt(document.getElementById("numTrees").value),
        maxDepth:parseInt(document.getElementById("maxDepth").value),
        minSamplesLeaf:parseInt(document.getElementById("minSamplesLeaf").value),
        minSamplesSplit:parseInt(document.getElementById("minSamplesSplit").value),
        maxFeatures:parseInt(document.getElementById("maxFeatures").value),
        criterion:document.getElementById("criterion").value,
        taskType:document.getElementById("taskType").value,
      };
      Object.assign(this.rf,hp);
      document.getElementById("forestInfo").textContent = "Hyperparameters set.";
    }
    loadCSV() {
      const txt = document.getElementById("csvInput").value;
      const nFeatures = parseInt(document.getElementById("numFeatures").value);
      const nSamples = parseInt(document.getElementById("numSamples").value);
      const rows = parseCSV(txt, nFeatures);
      const features = rows.map(r=>r.features);
      const targets = rows.map(r=>r.target);
      if (features.length===0) { alert("No data!"); return;}
      this.rf.loadData(features, targets, nFeatures, features.length);
      document.getElementById("forestInfo").textContent = "Loaded "+features.length+" samples.";
    }
    trainForest() {
      this.rf.fit();
      document.getElementById("trainStatus").textContent = "Training done. Trees: "+this.rf.trees.length;
    }
    predictSample() {
      const sample = document.getElementById("sampleInput").value.split(',').map(Number);
      const pred = this.rf.predict(sample);
      document.getElementById("predictResult").textContent = "Predicted: "+pred;
    }
    showFeatureImportances() {
      const importances = this.rf.featureImportances.map((v,i)=>`Feature${i}: ${v.toFixed(3)}`).join('\n');
      document.getElementById("featureImportances").textContent = importances;
    }
    showForestInfo() {
      const info = {
        numTrees: this.rf.trees.length,
        depth: this.rf.maxDepth,
        numFeatures: this.rf.numFeatures,
      };
      document.getElementById("forestInfo").textContent = JSON.stringify(info,null,2);
    }
    inspectTree(treeId=0) {
      const tree = this.rf.trees[treeId];
      if (!tree) { document.getElementById("facadeOutput").textContent = "No such tree."; return;}
      let out="";
      function recurse(node,depth=0) {
        if (!node) return;
        out+= "  ".repeat(depth)+ (node.isLeaf?`Leaf: pred=${node.prediction}`:`Split: x[${node.featureIndex}] <= ${node.threshold.toFixed(4)}`)+"\n";
        if (!node.isLeaf) { recurse(node.left,depth+1); recurse(node.right,depth+1);}
      }
      recurse(tree.root);
      document.getElementById("facadeOutput").textContent = out;
    }
  }

  // --- Facade instance for UI ---
  const facade = new RandomForestFacade();

  </script>
</body>
</html>
